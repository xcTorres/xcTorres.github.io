---
layout:     post
title:      "Leetcode"
date:       2019-03-09
author:     "xcTorres"
header-img: "img/in-post/leetcode.jpg"
catalog:    true
tags:
    - Leetcode
---

## 前言  
总感觉自己为了作为一名程序员，除了有良好的团队协作能力，代码规范，深厚的算法基础肯定还是必不可少的。记得之前为了找工作也有刷LeetCode，但当时条件下总是为了刷题而刷题，过于功利，只是为了面试能够考到原题。
现在这种状态就感觉比较轻松自由一些，也希望自己不那么功利，也不着急，也为了职业规划。所有解决方案题题目仅用Java语言和Python两种语言。

## 1. Two Sum

>**参考:**
[Two Sum](https://leetcode.com/articles/two-sum/)

Given an array of integers, return indices of the two numbers such that they add up to a specific target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
#### Example

```java

    Given nums = [2, 7, 11, 15], target = 9,
    Because nums[0] + nums[1] = 2 + 7 = 9,
    return [0, 1].

```

#### Java Solution
```java

  class Solution {
    public int[] twoSum(int[] nums, int target) {
        
        Map<Integer,Integer> table = new HashMap<>();
        
        for( int i = 0 ;i < nums.length ;i++ ){
            
            int other = target - nums[i];
            
            if( table.containsKey( other ) == true )
                return new int[]{ table.get(other) , i };
            
            table.put( nums[i] , i);
        }
         throw new IllegalArgumentException("No two sum solution");
    }
  }

```
#### Python Solution

```python

class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        
        table = {}
        try:
            for i in range(0,len(nums)):
                other = target - nums[i]
                if( other in table  ):
                    return [ table[other] , i]
                table[nums[i]] = i
        except IOError:
            print("No two sum solution")

```
#### 复杂度分析

时间复杂度: O(n); 遍历包含 n 个元素的列表一次; 每次在表中查找花费仅 O(1) 时间  
空间复杂度: O(n); 要求的额外空间依赖于存储在哈希表中的元素个数, 正好存储了 n 个元素  

## 2. Add Two Numbers
>**参考:**  
[Add Two Numbers](https://leetcode.com/problems/add-two-numbers/)  

You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.  
You may assume the two numbers do not contain any leading zero, except the number 0 itself.

#### Example:
```java

    Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)  
    Output: 7 -> 0 -> 8  
    Explanation: 342 + 465 = 807.

```
#### Java Solution
```java

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        
        ListNode dummy = new ListNode(-1);
        ListNode curNode = dummy;
        int carry = 0;
                
        while( l1!=null || l2!=null ){
            
            int x = l1!=null?l1.val:0;
            int y = l2!=null?l2.val:0;
            
            int tmp = x+y+carry;
            curNode.next = new ListNode(tmp%10);
            curNode = curNode.next;
            
            carry = tmp/10;
            l1 = l1!=null?l1.next:null;
            l2 = l2!=null?l2.next:null;
            
        }
        
        if(carry!=0)
            curNode.next = new ListNode(carry);
        
        return dummy.next;
    }
}

```

#### Python Solution

```python

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy = ListNode(-1)
        carry = 0
        curNode = dummy
        while ( l1 != None or l2 != None):
            x = l1.val if l1 != None else 0
            y = l2.val if l2 != None else 0
            tmp = x + y + carry
            carry = int(tmp/10)
            node = ListNode(int(tmp%10))
            curNode.next = node
            curNode = node
            l1 = l1.next if l1!=None else None
            l2 = l2.next if l2!=None else None

        if carry != 0:
            curNode.next = ListNode(carry)
        return dummy.next
```