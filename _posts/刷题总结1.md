1.Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.

Example 1:

Input: 121
Output: true
Example 2:

Input: -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.
Example 3:

Input: 10
Output: false
Explanation: Reads 01 from right to left. Therefore it is not a palindrome.
Follow up:

Coud you solve it without converting the integer to a string?
```
class Solution {
public:
    bool isPalindrome(int x) {


        if(x<0)
            return false;

        int d = 1;
        while(x/d>=10)d*=10;

        while(x>0){
            int l = x/d;
            int r = x%10;
            if(l!=r)
                return false;

            x = (x%d)/10;
            d /= 100;
        }

        return true;
    }

};
```
---
2.Given a string s, partition s such that every substring of the partition is a palindrome.

Return all possible palindrome partitioning of s.

For example, given s ="aab",
Return

  [
    ["aa","b"],
    ["a","a","b"]
  ]


# 解析
该问题可以看做一个普通的深度遍历的回溯问题
```
class Solution {
public:
    vector<vector<string>> partition(string s) {

        vector<string> solution;
        vector<vector<string>> result;

        dfs(s,solution,result,0);
        return result;
    }


    void dfs(string s , vector<string> solution , vector<vector<string>> &result , int cur){

        if(cur==s.size()){
            result.push_back(solution);
            return;
        }

        for(int i=cur;i<s.size();i++){

            if(!isPalindrome(s.substr(cur,i-cur+1)))
                continue;

            solution.push_back(s.substr(cur,i-cur+1));
            dfs(s,solution,result,i+1);
            solution.pop_back();
        }

    }


    bool isPalindrome(string s){

        int start = 0;
        int end = s.size()-1;

        while(start<end){
            if(s[start]!=s[end])
                return false;
            start++,end--;
        }
        return true;
    }
};
```

---
1.生成回文串

题目描述：
对于一个字符串，从前开始读和从后开始读是一样的，我们就称这个字符串是回文串。
例如”ABCBA”，”AA”，”A”是回文串，而”AAB”不是回文串。
牛牛特别喜欢回文串，他手中有一个字符串s，牛牛在思考能否从字符串中移除部分（0个或多个）字符使其变为回文串，并且牛牛认为空串不是回文串。
牛牛发现移除的方案可能有很多种，希望你来帮他计算一下一共有多少种移除方案可以使s变为回文串。
对于两种移除方案，如果移除的字符依次构成的序列不一样就是不同的方案。
输入描述：
输入包括一个字符串s(1 <= length(s) <= 50)，s中只包含大写字母
输出描述：
对于每个测试用例，输出一个正整数表示方案数
示例：
输入
XXY
输出
4

分析：动态规划

# 解析

https://blog.csdn.net/qq_31119477/article/details/79877571

使用动态规划，d[i][j]代表从字符i到字符j的回文子序列数。其状态转移方程为：
状态转移方程：
dp[i][j]=dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1] if（str[i]！=str[j]）
dp[i][j]=dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]+dp[i+1][j-1]+1=dp[i+1][j] + dp[i][j-1]+1 if （str[i]==str[j]）
即：
对于任意字符串，如果头尾字符不相等，则字符串的回文子序列个数就等于去掉头的字符串的回文子序列个数+去掉尾的字符串的回文子序列个数-去掉头尾的字符串的回文子序列个数；如果头尾字符相等，那么除了上述的子序列个数之外，还要加上首尾相等时新增的子序列个数，1+去掉头尾的字符串的回文子序列个数，1指的是加上头尾组成的回文子序列，如aa，bb等。
