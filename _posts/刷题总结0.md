---
layout:     post
title:      "刷题总结"
subtitle:   ""
date:       2018-5-27
author:     "xcTorres"
header-img: "img/post-bg-unix-linux.jpg"
tags:
    - 算法
---

[编程题] 彩色的砖块
时间限制：1秒

空间限制：32768K

小易有一些彩色的砖块。每种颜色由一个大写字母表示。各个颜色砖块看起来都完全一样。现在有一个给定的字符串s,s中每个字符代表小易的某个砖块的颜色。小易想把他所有的砖块排成一行。如果最多存在一对不同颜色的相邻砖块,那么这行砖块就很漂亮的。请你帮助小易计算有多少种方式将他所有砖块排成漂亮的一行。(如果两种方式所对应的砖块颜色序列是相同的,那么认为这两种方式是一样的。)
例如: s = "ABAB",那么小易有六种排列的结果:
"AABB","ABAB","ABBA","BAAB","BABA","BBAA"
其中只有"AABB"和"BBAA"满足最多只有一对不同颜色的相邻砖块。
输入描述:
输入包括一个字符串s,字符串s的长度length(1 ≤ length ≤ 50),s中的每一个字符都为一个大写字母(A到Z)。


输出描述:
输出一个整数,表示小易可以有多少种方式。

输入例子1:
ABAB

输出例子1:
2

# 解析：

当不同颜色超过两个时，无论如何排列都至少有两对不同颜色的排列。
```
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;
int main()
{
    string str;
    int res = 0;
    cin >> str;
    sort(str.begin(), str.end());
    //cout << str << endl;
    str.erase(unique(str.begin(), str.end()),str.end());
    if (str.size() == 1)
        res = 1;
    else if (str.size() == 2)
        res = 2;
    cout << res << endl;
    return 0;
}
```

---

[编程题] 等差数列
时间限制：1秒

空间限制：32768K

如果一个数列S满足对于所有的合法的i,都有S[i + 1] = S[i] + d, 这里的d也可以是负数和零,我们就称数列S为等差数列。
小易现在有一个长度为n的数列x,小易想把x变为一个等差数列。小易允许在数列上做交换任意两个位置的数值的操作,并且交换操作允许交换多次。但是有些数列通过交换还是不能变成等差数列,小易需要判别一个数列是否能通过交换操作变成等差数列
输入描述:
输入包括两行,第一行包含整数n(2 ≤ n ≤ 50),即数列的长度。
第二行n个元素x[i](0 ≤ x[i] ≤ 1000),即数列中的每个整数。


输出描述:
如果可以变成等差数列输出"Possible",否则输出"Impossible"。

输入例子1:
3
3 1 2

输出例子1:
Possible

# 解析

先进行排序，再看相邻的数是否等差。
```
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

int main(){
    int n;
    while(cin >> n){
        int tmp;
        vector<int> x;
        for(int i=0;i<n;i++){
            cin >> tmp;
            x.push_back(tmp);
        }
        sort(x.begin(),x.end());
        int d = x[1]-x[0];
        bool flag = true;
        for(int i=2;i<n;i++){
            if(x[i]-x[i-1]!=d){
                flag = false;
                break;
            }
        }
        if(flag)
            cout << "Possible" << endl;
        else
            cout << "Impossible" << endl;
        return 0;
    }

}
```
---
[编程题] 交错01串
时间限制：1秒

空间限制：32768K

如果一个01串任意两个相邻位置的字符都是不一样的,我们就叫这个01串为交错01串。例如: "1","10101","0101010"都是交错01串。
小易现在有一个01串s,小易想找出一个最长的连续子串,并且这个子串是一个交错01串。小易需要你帮帮忙求出最长的这样的子串的长度是多少。
输入描述:
输入包括字符串s,s的长度length(1 ≤ length ≤ 50),字符串中只包含'0'和'1'


输出描述:
输出一个整数,表示最长的满足要求的子串长度。

输入例子1:
111101111

输出例子1:
3

# 解析

```
#include<iostream>
using namespace std;
int main(){

    string s;
    cin >> s;
    int res = 1;
    int len = 1;
    for(int i=0;i<s.size();i++){
        if(i>0 && s[i]!=s[i-1]){
            len++;
        }else{
            res = max(res,len);
            len = 1;
        }
    }
    res = max(res,len);
    cout << res << endl;
    return 0;
}
```
---
[编程题] 堆棋子
时间限制：1秒

空间限制：32768K

小易将n个棋子摆放在一张无限大的棋盘上。第i个棋子放在第x[i]行y[i]列。同一个格子允许放置多个棋子。每一次操作小易可以把一个棋子拿起并将其移动到原格子的上、下、左、右的任意一个格子中。小易想知道要让棋盘上出现有一个格子中至少有i(1 ≤ i ≤ n)个棋子所需要的最少操作次数.

输入描述:
输入包括三行,第一行一个整数n(1 ≤ n ≤ 50),表示棋子的个数
第二行为n个棋子的横坐标x[i](1 ≤ x[i] ≤ 10^9)
第三行为n个棋子的纵坐标y[i](1 ≤ y[i] ≤ 10^9)


输出描述:
输出n个整数,第i个表示棋盘上有一个格子至少有i个棋子所需要的操作数,以空格分割。行末无空格

如样例所示:
对于1个棋子: 不需要操作
对于2个棋子: 将前两个棋子放在(1, 1)中
对于3个棋子: 将前三个棋子放在(2, 1)中
对于4个棋子: 将所有棋子都放在(3, 1)中

输入例子1:
4
1 2 4 9
1 1 1 1

输出例子1:
0 1 3 10

# 解析
https://www.nowcoder.com/questionTerminal/27f3672f17f94a289f3de86b69f8a25b

即要找到的点X必须是所有点中的某一个X，Y必须是所有点中的某一个Y。不一定要是所给的点，只需是所给点中的X与所给点的Y的组合。
```
#include<iostream>
#include<vector>
#include<limits.h>
#include<algorithm>
using namespace std;

int main(){

    int n;
    while(cin >> n){

        vector<int> X,Y;
        vector<int> minMove(n,INT_MAX);
        for(int i=0;i<n;i++){
            int tmp;
            cin>>tmp;
            X.push_back(tmp);
        }
        for(int i=0;i<n;i++){
            int tmp;
            cin>>tmp;
            Y.push_back(tmp);
        }

        for(auto x:X)
            for(auto y:Y){
                int tmp = 0;
                vector<int> dis(n,0);
                for(int i=0;i<n;i++){
                    dis[i] = abs(X[i]-x)+abs(Y[i]-y);
                }

                sort(dis.begin(), dis.end());
                for(int k = 0; k < n; ++k){
                    tmp += dis[k];
                    minMove[k] = min(minMove[k], tmp);
                }
            }

        for(int i=0;i<n-1;i++)
            cout <<  minMove[i] << " ";
        cout << minMove[n-1] << endl;
    }
    return 0;
}
```
---
1.生成回文串

题目描述：
对于一个字符串，从前开始读和从后开始读是一样的，我们就称这个字符串是回文串。
例如”ABCBA”，”AA”，”A”是回文串，而”AAB”不是回文串。
牛牛特别喜欢回文串，他手中有一个字符串s，牛牛在思考能否从字符串中移除部分（0个或多个）字符使其变为回文串，并且牛牛认为空串不是回文串。
牛牛发现移除的方案可能有很多种，希望你来帮他计算一下一共有多少种移除方案可以使s变为回文串。
对于两种移除方案，如果移除的字符依次构成的序列不一样就是不同的方案。
输入描述：
输入包括一个字符串s(1 <= length(s) <= 50)，s中只包含大写字母
输出描述：
对于每个测试用例，输出一个正整数表示方案数
示例：
输入
XXY
输出
4

分析：动态规划
