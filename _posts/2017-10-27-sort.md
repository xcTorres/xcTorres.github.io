---
layout:     post
title:      "Sort"
subtitle:   "排序算法"
date:       2017-10-27 
author:     "xcTorres"
header-img: "img/post-bg-ios9-web.jpg"
tags:
    - 算法
---

常用的排序有冒泡排序，直接插入排序，选择排序，快速排序，归并排序，堆排序，shell排序等几种方法。

 上文介绍过了时间复杂度。那么从时间复杂度来划分，可以分为。

![](/img/in-post/post-sort.png)
 
 
***

以下主要记录各算法的核心c++代码，用于加深对各个算法的理解，用于面试准备。

1.冒泡算法

即每次将数组中最大的数，放置最后。以此类推。

```
void bubble_sort(int* a,int length) {

    if (a == NULL || length==0)
        return ;

    int i,j,tmp;
    for(i=0 ;i<length-1;i++) {
        for(j=0;j<length-i;j++) {

           if (a[j]>a[j+1]) {
                tmp = a[j];
                a[j] = a[j+1];
                a[j+1] = tmp;
           }
        }
    }
}
```

2.选择排序算法。首先是在个数为N中的序列中找到最小值，放在位置0，再在剩下N-1的序列中找到最小值，放在位置1，以此类推。

```
template<typename T>
void selection_sort( vector<T>& arr) {
	for (int i = 0; i < arr.size() - 1; i++) {
		int min = i;
		for (int j = i + 1; j < arr.size(); j++)
			if (arr[j] < arr[min])
				min = j;
		swap(arr[i], arr[min]);
	}
}

```

3.直接插入排序。是选择未能排序的数，一个一个插入已经排序好的数组。

```
template<typename T>
void insert_sort( vector<T>& arr) {

    for(int i=0;i< arr.size();i++) {
        for(int j=i;j>0;j--) {

            if(arr[j] < arr[j-1] ) {
                swap(arr[j], arr[j-1]);
            }

        }
    }
}
```

4.快速排序，示例为数组最后一个数为基准，生成一个新的数组，使其左边的序列比基准小，右边的数比其大。然后分别再对左序列，右序列进行同样的操作。以此类推。

```
//数据交换，使得新数组中，基准数字左边的数都小于它，右边的数字都大于它。并返回基准数字在新数组的下标
int  partition(int arr[] , int low , int high) {

    int pivot = arr[high];

    int pi = low-1;
    for( int i=low ; i<=high-1 ;i++) {
        if ( arr[i] <= pivot) {
            pi++;
            swap(arr[i], arr[pi]);
        }

    }

    swap(arr[pi+1],arr[high]);
    return (pi+1);

}

//递归快速排序
void quickSort(int arr[], int low,int high) {

	if (low < high) {

		int pi = partition(arr, low, high);

		quickSort(arr, low, pi - 1);
		quickSort(arr, pi + 1, high);
	}
}
```

5.归并排序

归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。

将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。

从下图我们可以看出其分而治之的思想。
![](http://images2015.cnblogs.com/blog/318837/201604/318837-20160422105330898-383478645.png)

其核心代码如下。

```
//将有二个有序数列a[first...mid]和a[mid...last]合并。
void mergearray(int a[], int first, int mid, int last)
{
    int i = first, j = mid + 1;
    int k = 0;
    int* temp = new int[last-first+1];

    while (i <= mid && j <= last)
    {
        if (a[i] <= a[j])
            temp[k++] = a[i++];
        else
            temp[k++] = a[j++];
    }

    while (i <= mid)
        temp[k++] = a[i++];

    while (j <= last)
        temp[k++] = a[j++];

    for (i = 0; i < k; i++)
        a[first + i] = temp[i];
}

void mergesort(int a[], int first, int last)
{
    if (first < last)
    {
        int mid = (first + last) / 2;
        mergesort(a, first, mid);    //左边有序
        mergesort(a, mid + 1, last); //右边有序
        mergearray(a, first, mid, last); //再将二个有序数列合并
    }
}
```






