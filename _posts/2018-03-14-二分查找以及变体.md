---
layout:     post
title:      "二分查找以及变体"
subtitle:   "算法"
date:       2017-4-27 
author:     "xcTorres"
header-img: "img/post-bg-ios9-web.jpg"
tags:
    - 代码，算法
---




在算法过程中经常会考到二分查找的变体，所以打算总结一下。

### 1.二分查找的非递归实现
```
//非递归实现  
int BinarySearch(int array[], int len, int value)  
{  
    if (array == NULL || len <= 0)  
        return -1;  
  
    int low = 0;  
    int high = len - 1;  
    while (low <= high)  
    {  
        int mid = low + (high - low) / 2;  
        if (array[mid] == value)  
            return mid;  
        else if (array[mid] > value)  
            high = mid - 1;  
        else  
            low = mid + 1;  
    }  
  
    return -1;  
}  
```
### 2、二分查找的递归实现
```
//递归实现  
int BinarySearch_Recursive(int array[], int low, int high, int value)  
{  
    if (low > high)  
        return -1;  
    int mid = low + (high - low) / 2;  
    if (array[mid] == value)  
        return mid;  
    else if (array[mid] > value)  
        return BinarySearch_Recursive(array, low, mid - 1, value);  
    else  
        return BinarySearch_Recursive(array, mid + 1, high, value);  
  
}  
```
---

### 3.变体1:  旋转数组中的最小数字

解法1：

采用二分法解答这个问题，

mid = low + (high - low)/2

需要考虑三种情况：

(1)array[mid] > array[high]:

出现这种情况的array类似[3,4,5,6,0,1,2]，此时最小数字一定在mid的右边。

low = mid + 1

(2)array[mid] == array[high]:

出现这种情况的array类似 [1,0,1,1,1] 或者[1,1,1,0,1]，此时最小数字不好判断在mid左边
还是右边,这时只好一个一个试 ，

high = high - 1

(3)array[mid] < array[high]:

出现这种情况的array类似[2,2,3,4,5,6,6],此时最小数字一定就是array[mid]或者在mid的左
边。因为右边必然都是递增的。

high = mid

**注意这里有个坑：如果待查询的范围最后只剩两个数，那么mid 一定会指向下标靠前的数字**
比如 array = [4,6]
array[low] = 4 ;array[mid] = 4 ; array[high] = 6 ;

如果high = mid - 1，就会产生错误， 因此high = mid
但情形(1)中low = mid + 1就不会错误


```
class Solution {
public:
    int minNumberInRotateArray(vector<int> arr) {
        
        if(arr.size()==0)
            return 0;
        
        int left =0;
        int right=arr.size()-1;
        
        int mid = 0;
        while(left<right){
            
            mid = (left+right)/2;
            if(arr[mid]>arr[right])
                left = mid+1;
            else if(arr[mid] < arr[right])
                right = mid;
            else
                right = right-1;
        }
        
        return arr[left];
    }
};
```
解法2

```
/* 
 *  Obveriously, to search any sorted array, the binary search is the common sense.
 * 
 *  To solve this problem, the idea is same as the search in rotated sorted array.
 */
int findMin(vector<int> &num) {

    int low=0, high=num.size()-1;

    while(high-low>1){
        int mid = low + (high-low)/2;
        // Chek the array if it is non-rotated, then just return the first element.
        if (num[low] < num[mid] && num[mid] < num[high]){
            return num[low];
        }

        // The array is rotated
        // Split it into two part, the minimal value must be the rotated part
        
        // if the left part is rotated, warch the left part
        if (num[low] > num [mid]){
            high = mid;
            continue;
        }
        // if the right part is rotated, search the right part.
        if (num[mid] > num[high]){
            low = mid;
            continue;
        }
    }
    // the array only has 1 element
    if (high == low) return num[low];

    // the array has 2 elements
    return num[low] < num[high] ? num[low] : num[high];

}
```


---
### 4.变体2，求顺序数组（含重复的）数字的lowerBound，upperBound。

```
    int lowerBound(vector<int> data ,int target){
        
        int low = 0;
        int high = data.size()-1;
        
        int result = -1;
        
        while(low<=high){
            int mid = low+(high-low)/2;
            if(data[mid]>target){
                high = mid-1;
            }else if(data[mid]<target){
                low = mid+1;
            }else{
                result = mid;
                high = mid -1;
            }
        }
        return result;
    }
    
    int upperBound(vector<int> data ,int target){
        
        int low = 0;
        int high = data.size()-1;
        
        int result = -1;
        
        while(low<=high){
            int mid = low+(high-low)/2;
            if(data[mid]>target){
                high = mid-1;
            }else if(data[mid]<target){
                low = mid+1;
            }else{
                result = mid;
                low = mid+1;
            }
        }
        return result;
    }
```
---
### 5.变体3 旋转数组查找（不含重复数字）

```
/*
 *    Using binary search idea, 
 *    1) Spliting the array to two part, one part should be non-rotated, another one is rotated.
 *    2) Checking the "key" whether is possible in non-rotated sorted part.
 *        2.1) if it is, then go to the classcial binary searh.
 *        2.2) if it not, then keep spliting the rorated part.
 *
 */
int search1(int A[], int n, int key) {
    if (n<=0) return -1;

    if (n==1){
        return (A[0]==key) ? 0 : -1;
    }
    int low=0, high=n-1;
    while( low<=high ){

        if (A[low] <= A[high] && ( key < A[low] || key > A[high]) ) {
             return -1;
        }

        int mid = low + (high-low)/2;
        if ( A[mid] == key ) return mid;
    
        //the target in non-rotated array
        if (A[low] < A[mid] && key >= A[low] && key< A[mid]){
            high = mid - 1;
            continue;
        }
        //the target in non-rotated array
        if (A[mid] < A[high] && key > A[mid] && key <= A[high] ){
            low = mid + 1;
            continue;
        }
        //the target in rotated array
        if (A[low] > A[mid] ){
            high = mid - 1;
            continue;
        }
        //the target in rotated array
        if (A[mid] > A[high] ){
            low = mid + 1;
            continue;
        }
    }
    return -1;
}

```

---
### 6.变体4（含重复数字）旋转数组查找
```
/********************************************************************************** 
* 
* Follow up for "Search in Rotated Sorted Array":
* What if duplicates are allowed?
* 
* Would this affect the run-time complexity? How and why?
* 
* Write a function to determine if a given target is in the array.
*               
**********************************************************************************/

// Using the same idea "Search in Rotated Sorted Array"
// but need be very careful about the following cases:
//   [3,3,3,4,5,6,3,3] 
//   [3,3,3,3,1,3]
// After split, you don't know which part is rotated and which part is not.
// So, you have to skip the ducplication
//   [3,3,3,4,5,6,3,3] 
//          ^       ^
//   [3,3,3,3,1,3]
//            ^ ^
class Solution {
public:
    bool search(int A[], int n, int key) {
        if (n<=0) return false;
    
        if (n==1){
            return (A[0]==key) ? true : false;
        }
        int low=0, high=n-1;
        while( low<=high ){
    
            if (A[low] < A[high] && ( key < A[low] || key > A[high]) ) {
                 return false;
            }
            
            //if dupilicates, remove the duplication
            while (low < high && A[low]==A[high]){
                low++;
            }
    
            int mid = low + (high-low)/2;
            if ( A[mid] == key ) return true;
    
            //the target in non-rotated array
            if (A[low] < A[mid] && key >= A[low] && key< A[mid]){
                high = mid - 1;
                continue;
            }
            //the target in non-rotated array
            if (A[mid] < A[high] && key > A[mid] && key <= A[high] ){
                low = mid + 1;
                continue;
            }
            //the target in rotated array
            if (A[low] > A[mid] ){
                high = mid - 1;
                continue;
            }
            //the target in rotated array
            if (A[mid] > A[high] ){
                low = mid + 1;
                continue;
            }
            
            //reach here means nothing found.
            low++;
        }
        return false;
    }
    
    
};
```

